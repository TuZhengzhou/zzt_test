g++ -o 

- 如果需要指定额外的头文件搜索路径DIRECTORY（编译可执行文件、动态链接库文件……等文件时），使用 -Idir 参数
- 生成动态链接库时（.dll或.so文件），使用 -shared 参数，生成的链接库文件需要以 lib 前缀开头（如 libdynamic.so）
- 编译可执行文件f时，如果f在执行时需要使用动态链接库文件，则编译 f 文件时，需要指定动态链接库目录（使用 -L[dir] 参数）和动态链接库名称（使用 -l[dynamic] 参数）
- 需要动态链接库的可执行文件 f，在执行时，需要获知动态链接库所在目录，有两种实现方式：
    - 在编译 f 文件时，使用 -Wl,-rpath=[libpath] 参数，将[libpath]目录添加到运行时库搜索路径
    - 如果没有使用 -Wl,-rpath=[libpath] 参数，则需要在运行前手动设置环境变量 export LD_LIBRARY_PATH=[libpath]:$LD_LIBRARY_PATH

示例：编译 code_split_src_call.cpp 文件为 code_split 可执行文件

    方法1：不使用动态链接库

        g++ -Iinc2 -Iincludes code_split_src_def.cpp code_split_src_call.cpp -o code_split

        交换参数顺序也是可以的

        g++ -o code_split -Iinc2 -Iincludes code_split_src_def.cpp code_split_src_call.cpp

        ./code_split

    方法2：使用动态链接库

        将 code_split_src_def.cpp 首先编译为动态链接库，如下

        g++ -shared -Iinc2 -Iincludes code_split_src_def.cpp -o libcode_split_src_def.so

        编译 code_split 并添加运行时库搜索目录（注意动态链接相关的参数应当放在目标文件后）

        g++ -Iinc2 -Iincludes -Wl,-rpath=lib code_split_src_call.cpp -o code_split -Llib -lcode_split_src_def

        ./code_split

编译检查
    -Werror 把警告当作错误。出现任何警告就放弃编译。
    -w (小写)禁止所有警告信息
    -W[必填option] 以"-W"(大写)开头开启特定的警告
        例如：
        -Wunused-variable
        -Wuninitialized
        -Wreturn-local-addr

    -Wno- 以"-Wno-"(大写)开头关闭特定的警告
        例如：
        -Wno-unused-variable
        -Wno-uninitialized
        -Wno-return-local-addr

    -Wall 打开大部分warning
        -Werror=unused-variable
        -Wno-uninitialized
        -Wno-return-local-addr

    -Wextra 打开一些特定warning。-Wall不包括-Wextra
        -Wunreachable-code 如果编译器探测到永远不会执行到的代码，就给出警告
        -Werror=unused-parameter 函数形参未使用过
        
    -Wshadow 当一个局部变量遮盖住了另一个局部变量，或者全局变量时，给出警告。很有用的选项，建议打开。 -Wall -Wextra 并不会打开此项。

    -Wpointer_arith 对函数指针或者void *类型的指针进行算术操作时给出警告.-Wall 并不会打开此项

    -Winline 函数声明为 inline 但不能内联（例如递归调用）时报错(似乎只有在该函数标记为 __attribute__((always_inline)) 时(强制内联)且强制内联失败才会触发)
